---
title: Timestamp 란
description: 현재 시스템에서 사용하고 있는 Timestamp에 대한 개념과 사용법을 정리
thumbnailUrl: /posts/thumbnail/03.png
tags: [ 'timestamp' ]
date: 2025-03-16 16:50:00
---

# Unix Time 이전의 시간 저장 방식

### 1. Date String

```markdown
2025-03-15 20:30:10
```

1. 장점
  - 사람이 읽고 이해할 수 있는 형태로 가독성이 좋음
2. 단점
  - 문자열로 저장되어 있다보니 날짜를 비교에 변환 과정이 추가로 필요
  - 각 시스템에서 타임존에 따른 문제점 발생

### 2. 이진수 or BCD(Binary Coded Decimal) 방식

|    항목    |     이진수     |         BCD         |
|:--------:|:-----------:|:-------------------:|
| 연 (2025) | 11111100101 | 0010 0000 0010 0101 |
|  월 (03)  |  00000011   |      0000 0011      |
|  일 (15)  |  00001111   |      0001 0101      |
|  시 (20)  |  00010100   |      0010 0000      |
|  분 (30)  |  00111110   |      0011 0000      |
|  초 (10)  |  00001010   |      0001 0000      |

1. 장점
  - 이진수로 저장을 하다보니 컴퓨터가 이해하기 쉬움
  - 이진법 숫자 연산을 통해 시간 비교나 계산 빠름
2. 단점
  - 사람이 이해하기 어려움
  - 각 시스템에서 타임존에 따른 문제점 발생

### 3. Timestamp

```markdown
2025-03-15T20:30:10Z (Z = Zulu Time = UTC)
2025-03-15T20:30:10+09:00 (UTC+9 시간대)
```

1. 장점
  - 사람이 이해하기 쉬움
  - 시간대를 포함하고 있음
2. 단점
  - 타임스탬프 형태이지만 문자열로 저장하기 때문에 저장 공간이 많이 필요함
  - 문자열로 저장하기 때문에 비교나 계산에서 추가 변환 과정이 필요함

이 외에도 날짜와 시간을 다른 필드로 별도 관리하는 방법이나 다양한 방법들이 있지만, 이러한 방식들은 시간 비교 계산이나 시간대의 문제에서 많은 한계를 마주치게 되었고,

그래서 **Unix Time**은 시간 계산 편리를 위해 숫자로 관리를 하고 있고, UTC라는 기준 시간대를 사용하여 동일한 기준으로 시간을 관리하게 되었다.

> **Unix Time ? Timestamp ?**Timestamp를 직역하면 **시간 도장**이라는 의미인데, 특정 시점의 기록을 도장처럼 기록하는 의미를 가지고 있다. **Unix Time**은 이러한 Timestamp의 표현 방식 중 하나로, 정수 형태로
> 초를 기록하는 방식이다.ex.`2025-03-15T20:30:10Z` : 사람이 읽을 수 있는 형태로 표현한 Timestamp

<hr />

# Unix Time

```markdown
UNIX 시간(UNIX time)은 시각을 나타내는 방식이다. POSIX 시간이나 Epoch 시간이라고 부르기도 한다.
1970년 1월 1일 00:00:00 협정 세계시(UTC) 부터의 경과 시간을 초로 환산하여 정수로 나타낸 것이다.
```

[Wikipedia - Unix Time](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%8B%9C%EA%B0%84) 에 적혀있는 Unix Time에
대한 설명인데,

**1970년 01월 01알 00:00:00 시를 0으로 기준을 설정하고, 그 이후에 흘러간 시간을 초로 환산하여 32bit 의 정수로 나타낸 것이 Unix Time 이다.**

> **Unix Time이 1970-01-01 00:00:00 이 기준이 된 이유**Unix가 처음 개발될 1970년대 당시에 개발자들이 정한 기준점이라고 한다.
> 그래서 그 이전의 시간은 음수값으롲 정의된다.

### 특징

##### 1. Epoch Time (기준 시간)이 있다.

- `Epoch` : 1970-01-01 00:00:00 UTC

##### 2. 초 단위로 시간을 관리한다.

- `1742043549` : 2025년 3월 15일 토요일 21시 59분 11초

##### 3. 기준이 되는 타임존은  UTC이다.

### 문제점

이러한 유용한 Unix Time에도 문제점이 존재하는데,

##### 1. [윤초](https://ko.wikipedia.org/wiki/%EC%9C%A4%EC%B4%88)를 고려하지 않음

- 지구 자전 속도에 따라 추가되는 초인 윤초를 고려하지 않고 있다.

##### 2. 2038년 문제 (Y2K38)

이건 이번에 Timestamp에 대한 공부를 하면서 깨닫게 되었는데, 생각해보면 무한한 시간을 유한한 숫자로 표현하게 만들어 두었다는 거에 있어서 한계가 있을 텐데 그게 바로 이 2038년 문제라고 한다.

- Unix Time은 1970-01-01 00:00:00 UTC를 기준으로 경과한 초를 32비트 정수로 저장하고 있기 때문에, **32bit (2,147,483,647)** 까지 표현 가능하다.
- `1970-01-01 00:00:00 으로부터 2147483647초 후`는 2038년 1월 19일 03:14:07 UTC 이기 때문에 **2038년 문제**라고 불리운다.
- 그 이후의 시간은 오버플로우(overflow)가 발생하여 음수로 변환되어 날짜계산에 문제가 발생하게 된다.
- **해결방법** : 32bit 방식을 64bit 방식으로 처리하게 되면 해결됨

<hr />

# Timestamp 사용법
### Linux/Unix
```shell title="Linux/Unix Timestamp"
> date +%s
1742045410
```

```shell title="Linux/Unix Timestamp(날짜/시간)"
> date
Sat Mar 15 20:30:10 UTC 2025
```

### Java
```java title="Java Timestamp"
long currentUnixTimeMs = System.currentTimeMillis();
System.out.println(currentUnixTimeMs); // 1742045410000
```

```java title="Java Timestamp (날짜/시간)"
import java.util.Date;


public static void main(String[] args) {
    long currentUnixTimeMs = System.currentTimeMillis();
    Date date = new Date(currentUnixTimeMs);
    System.out.println(date.toString()); // Mon Mar 15 20:30:10 GMT 2025
}
```

```java title="Java Timestamp (날짜/시간) - Java8 이상"
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;


public static void main(String[] args) {
    long currentUnixTimeMs = System.currentTimeMillis();
    Instant instant = Instant.ofEpochMilli(currentUnixTimeMs);
    String formattedDate = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
                            .withZone(ZoneId.systemDefault())
                            .format(instant);
    System.out.println(formattedDate); // 2025-03-15 20:30:10
}
```

### Python
```python title="Python Timestamp"
current_unix_time_ms = int(time.time() * 1000)
print(current_unix_time_ms) # 1742043549000
```

```python title="Python Timestamp (날짜/시간)"
from datetime import datetime

unix_time_ms = int(time.time())
converted_time = datetime.utcfromtimestamp(unix_time_ms)
print(converted_time) # 2025-03-15 20:30:10
```

### Javascript
```javascript title="Javascript Timestamp"
let currentUnixTimeMs = Date.now()
console.log(currentUnixTimeMs) // 1742043549000
```

```javascript title="Javascript Timestamp (날짜/시간)"
let date = new Date.now()
console.log(date.toUTCString()) // Sat, 15 Mar 2025 20:30:10 GMT
```

### Mysql

현재 프로젝트에서는 Java와 Mysql을 사용하고 있는데, 금융권이다보니 정말 이런 곳에서도 폐쇄적인 건지..아무튼 타임스탬프를 사용하기 위해서 데이터베이스 관리 부서와의 협의과정을 거쳐서 겨우 사용하게 되었다.

그렇게 해서 사용하게 된 현재 프로젝트의 타임스탬프를 저장하는 컬럼의 타입은 `CHAR(13)`으로 설정이 되어있다.

현재 사용하고 있는 방식은 spring boot 에서 querydsl 로 데이터베이스에 저장을 할 때 `System.currentTimeMillis()`을 통해 직접 set을 하는 방식인데, 원래 mysql에서는 `TIMESTAMP`라는 속성도 있다는 것을 알게 되었다.

```mysql
mysql> CREATE TABLE TEST_DB (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name varchar(30),
    craete_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


mysql> INSERT INTO TEST_DB (name) VALUES ('Sample name');
+----+-------------+---------------------+
| id | name        | craete_at           |
+----+-------------+---------------------+
|  1 | Sample name | 2025-03-16 21:54:50 |
+----+-------------+---------------------+
```

아래에서는 타임스탬프를 ms까지 포함하는 컬럼을 의미한다.

```mysql
mysql> CREATE TABLE TEST_DB_MS (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name varchar(30),
    craete_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


mysql> INSERT INTO TEST_DB_MS (name) VALUES ('Sample name');
+----+-------------+-------------------------+
| id | event_name  | event_time              |
+----+-------------+-------------------------+
|  1 | Sample name | 2025-03-16 22:07:55.981 |
+----+-------------+-------------------------+
```
하지만 위의 방식은 여전히 타임존을 포함하고 있지 않기 때문에 지금 프로젝트에서는 적합하지 않았고, 그래서 mysql 에서도 만약 Unix Timestamp를 활용하고 싶다면

```mysql
mysql> CREATE TABLE TEST_DB_UNIX_TIME (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    create_at BIGINT
);


mysql> INSERT INTO TEST_DB_UNIX_TIME (create_at) VALUES (UNIX_TIMESTAMP());
+----+-------------+
| id |  create_at  |
+----+-------------+
|  1 | 1742130982  |
+----+-------------+
```
만약, 해당하는 값을 사람이 이해할 수 있게 조회를 하게 된다면 `FROM_UNIXTIME`을 사용하면 된다.
```mysql
mysql> SELECT id, FROM_UNIXTIME(create_at) AS read_time FROM TEST_DB_UNIX_TIME;

+----+---------------------+
| id |     read_time       |
+----+---------------------+
|  1 | 2025-03-16 22:16:22 |
+----+---------------------+
```

위에서 계속 얘기했던 타임존을 포함한 시간을 조회하기 위해선, 일단 본인의 서버 타임존을 확인해본다. 나는 기본 SYSTEM 타임존을 따르는 것을 확인할 수 있고,
```mysql
mysql> SELECT @@global.time_zone, @@session.time_zone, @@system_time_zone;
+--------------------+---------------------+
| @@global.time_zone | @@session.time_zone |
+--------------------+---------------------+
| SYSTEM             | SYSTEM              |
+--------------------+---------------------+
```
디폴트 타임존 설정이 되어 있지 않을 경우, 현재 내가 원하는 타임존으로 조회할 수 있는 방법은 `CONVERT_TZ`를 통해 조회할 수 있다.
```mysql
mysql> SELECT id, CONVERT_TZ(FROM_UNIXTIME(create_at), '+00:00', '-09:00') AS seoul_time FROM TEST_DB_UNIX_TIME;
+----+---------------------+
| id | seoul_time          |
+----+---------------------+
|  1 | 2025-03-16 13:16:22 |
+----+---------------------+
```

추가로 [7.1.15 MySQL Server Time Zone Support](https://dev.mysql.com/doc/refman/8.4/en/time-zone-support.html)에서 타임존에 대한 Mysql에 대한 설명을 볼 수 있었다.
간단하게 요약해보면,
MySQL 서버의 초기 글로벌 서버 시간대는 `default-time-zone` 설정을 통해 할 수 있고,
```mysql
default-time-zone='timezone'
```

만약, `SYSTEM_VARIABLES_ADMIN` 권한이 존재하면 다음 명령어로 설정하고 조회할 수 있다.
```mysql
SET GLOBAL time_zone = timezone;
```

여기서의 세션 시간대 설정은 `NOW()` 또는 `CURTIME()`과 같은 함수에서 표시하는 값과 TIMESTAMP 열에 저장되고 검색되는 값이 포함된다.
하지만, `UTC_TIMESTAMP()`, `DATE`, `TIME`, `DATETIME` 로 저장된 값의 경우는 시간대에 영향을 받지 않기 때문에 시간대를 설정한다고 해서 자동으로 변환되는 것이 아니다.

`UTC_TIMESTAMP()`는 항상 UTC 기준으로 조회가 되는 것을 확인할 수 있다.
```mysql
mysql> SET time_zone = 'Asia/Seoul';

mysql> SELECT UTC_TIMESTAMP();
+---------------------+
| UTC_TIMESTAMP()     |
+---------------------+
| 2025-03-16 13:55:08 |  -- UTC 기준으로 출력됨
+---------------------+
```
하지만, `TIMESTAMP`는 값은 UTC로 저장되고, 조회할 때 세션 시간대에 맞게 변환된다.
```mysql
mysql> SET time_zone = 'Asia/Seoul';
mysql> INSERT INTO TEST_DB_UNIX_TIME (create_at) VALUES (UNIX_TIMESTAMP());
mysql> SELECT create_at FROM TEST_DB_UNIX_TIME;
+---------------------+
| create_at           |
+---------------------+
| 2025-03-16 22:16:22 |  -- 서울 시간(UTC+9)이 출력됨
+---------------------+
```


