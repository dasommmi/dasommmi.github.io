<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/268d08043a30bfbf.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-f029a09104d09cbc.js"/><script src="/_next/static/chunks/4bd1b696-2bfa57da125389e3.js" async=""></script><script src="/_next/static/chunks/587-c7f2815ecf19825a.js" async=""></script><script src="/_next/static/chunks/main-app-f803f0036d3a6c59.js" async=""></script><script src="/_next/static/chunks/app/page-e75cc3ebefafaa5f.js" async=""></script><meta name="next-size-adjust" content=""/><title>My Blog</title><meta name="description" content="Sandy&#x27;s Blog"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><div class="mx-auto flex min-h-screen max-w-screen-xl flex-col px-4 sm:px-6 md:px-8 lg:px-12"><header class="container mx-auto max-w-screen-md p-4"><a href="/">Hello, World</a></header><main class="container mx-auto max-w-screen-md flex-1 p-4"><ul class="flex flex-wrap justify-start gap-6"><a class="w-full" href="/posts/03_Timestamp"><li class="flex w-full flex-wrap gap-6 rounded-lg bg-gray-200 px-5 py-4 shadow-md transition duration-300 hover:shadow-lg"><div class="flex flex-1 flex-wrap gap-2"><h3 class="w-full text-lg font-semibold text-gray-800">Timestamp 란</h3><p class="w-full text-sm text-gray-600">현재 시스템에서 사용하고 있는 Timestamp에 대한 개념과 사용법을 정리</p><div class="flex w-full gap-2"><div class="rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900">timestamp</div></div><p class="w-full text-sm text-gray-800">2025-03-16 16:50:00</p></div><div class="m-auto"></div><div>
# Unix Time 이전의 시간 저장 방식

### 1. Date String

```markdown
2025-03-15 20:30:10
```

1. 장점
  - 사람이 읽고 이해할 수 있는 형태로 가독성이 좋음
2. 단점
  - 문자열로 저장되어 있다보니 날짜를 비교에 변환 과정이 추가로 필요
  - 각 시스템에서 타임존에 따른 문제점 발생

### 2. 이진수 or BCD(Binary Coded Decimal) 방식

|    항목    |     이진수     |         BCD         |
|:--------:|:-----------:|:-------------------:|
| 연 (2025) | 11111100101 | 0010 0000 0010 0101 |
|  월 (03)  |  00000011   |      0000 0011      |
|  일 (15)  |  00001111   |      0001 0101      |
|  시 (20)  |  00010100   |      0010 0000      |
|  분 (30)  |  00111110   |      0011 0000      |
|  초 (10)  |  00001010   |      0001 0000      |

1. 장점
  - 이진수로 저장을 하다보니 컴퓨터가 이해하기 쉬움
  - 이진법 숫자 연산을 통해 시간 비교나 계산 빠름
2. 단점
  - 사람이 이해하기 어려움
  - 각 시스템에서 타임존에 따른 문제점 발생

### 3. Timestamp

```markdown
2025-03-15T20:30:10Z (Z = Zulu Time = UTC)
2025-03-15T20:30:10+09:00 (UTC+9 시간대)
```

1. 장점
  - 사람이 이해하기 쉬움
  - 시간대를 포함하고 있음
2. 단점
  - 타임스탬프 형태이지만 문자열로 저장하기 때문에 저장 공간이 많이 필요함
  - 문자열로 저장하기 때문에 비교나 계산에서 추가 변환 과정이 필요함

이 외에도 날짜와 시간을 다른 필드로 별도 관리하는 방법이나 다양한 방법들이 있지만, 이러한 방식들은 시간 비교 계산이나 시간대의 문제에서 많은 한계를 마주치게 되었고,

그래서 **Unix Time**은 시간 계산 편리를 위해 숫자로 관리를 하고 있고, UTC라는 기준 시간대를 사용하여 동일한 기준으로 시간을 관리하게 되었다.

&gt; **Unix Time ? Timestamp ?**Timestamp를 직역하면 **시간 도장**이라는 의미인데, 특정 시점의 기록을 도장처럼 기록하는 의미를 가지고 있다. **Unix Time**은 이러한 Timestamp의 표현 방식 중 하나로, 정수 형태로
&gt; 초를 기록하는 방식이다.ex.`2025-03-15T20:30:10Z` : 사람이 읽을 수 있는 형태로 표현한 Timestamp

&lt;hr /&gt;

# Unix Time

```markdown
UNIX 시간(UNIX time)은 시각을 나타내는 방식이다. POSIX 시간이나 Epoch 시간이라고 부르기도 한다.
1970년 1월 1일 00:00:00 협정 세계시(UTC) 부터의 경과 시간을 초로 환산하여 정수로 나타낸 것이다.
```

[Wikipedia - Unix Time](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%8B%9C%EA%B0%84) 에 적혀있는 Unix Time에
대한 설명인데,

**1970년 01월 01알 00:00:00 시를 0으로 기준을 설정하고, 그 이후에 흘러간 시간을 초로 환산하여 32bit 의 정수로 나타낸 것이 Unix Time 이다.**

&gt; **Unix Time이 1970-01-01 00:00:00 이 기준이 된 이유**Unix가 처음 개발될 1970년대 당시에 개발자들이 정한 기준점이라고 한다.
&gt; 그래서 그 이전의 시간은 음수값으롲 정의된다.

### 특징

##### 1. Epoch Time (기준 시간)이 있다.

- `Epoch` : 1970-01-01 00:00:00 UTC

##### 2. 초 단위로 시간을 관리한다.

- `1742043549` : 2025년 3월 15일 토요일 21시 59분 11초

##### 3. 기준이 되는 타임존은  UTC이다.

### 문제점

이러한 유용한 Unix Time에도 문제점이 존재하는데,

##### 1. [윤초](https://ko.wikipedia.org/wiki/%EC%9C%A4%EC%B4%88)를 고려하지 않음

- 지구 자전 속도에 따라 추가되는 초인 윤초를 고려하지 않고 있다.

##### 2. 2038년 문제 (Y2K38)

이건 이번에 Timestamp에 대한 공부를 하면서 깨닫게 되었는데, 생각해보면 무한한 시간을 유한한 숫자로 표현하게 만들어 두었다는 거에 있어서 한계가 있을 텐데 그게 바로 이 2038년 문제라고 한다.

- Unix Time은 1970-01-01 00:00:00 UTC를 기준으로 경과한 초를 32비트 정수로 저장하고 있기 때문에, **32bit (2,147,483,647)** 까지 표현 가능하다.
- `1970-01-01 00:00:00 으로부터 2147483647초 후`는 2038년 1월 19일 03:14:07 UTC 이기 때문에 **2038년 문제**라고 불리운다.
- 그 이후의 시간은 오버플로우(overflow)가 발생하여 음수로 변환되어 날짜계산에 문제가 발생하게 된다.
- **해결방법** : 32bit 방식을 64bit 방식으로 처리하게 되면 해결됨

&lt;hr /&gt;

# Timestamp 사용법
### Linux/Unix
```shell title=&quot;Linux/Unix Timestamp&quot;
&gt; date +%s
1742045410
```

```shell title=&quot;Linux/Unix Timestamp(날짜/시간)&quot;
&gt; date
Sat Mar 15 20:30:10 UTC 2025
```

### Java
```java title=&quot;Java Timestamp&quot;
long currentUnixTimeMs = System.currentTimeMillis();
System.out.println(currentUnixTimeMs); // 1742045410000
```

```java title=&quot;Java Timestamp (날짜/시간)&quot;
import java.util.Date;


public static void main(String[] args) {
    long currentUnixTimeMs = System.currentTimeMillis();
    Date date = new Date(currentUnixTimeMs);
    System.out.println(date.toString()); // Mon Mar 15 20:30:10 GMT 2025
}
```

```java title=&quot;Java Timestamp (날짜/시간) - Java8 이상&quot;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;


public static void main(String[] args) {
    long currentUnixTimeMs = System.currentTimeMillis();
    Instant instant = Instant.ofEpochMilli(currentUnixTimeMs);
    String formattedDate = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)
                            .withZone(ZoneId.systemDefault())
                            .format(instant);
    System.out.println(formattedDate); // 2025-03-15 20:30:10
}
```

### Python
```python title=&quot;Python Timestamp&quot;
current_unix_time_ms = int(time.time() * 1000)
print(current_unix_time_ms) # 1742043549000
```

```python title=&quot;Python Timestamp (날짜/시간)&quot;
from datetime import datetime

unix_time_ms = int(time.time())
converted_time = datetime.utcfromtimestamp(unix_time_ms)
print(converted_time) # 2025-03-15 20:30:10
```

### Javascript
```javascript title=&quot;Javascript Timestamp&quot;
let currentUnixTimeMs = Date.now()
console.log(currentUnixTimeMs) // 1742043549000
```

```javascript title=&quot;Javascript Timestamp (날짜/시간)&quot;
let date = new Date.now()
console.log(date.toUTCString()) // Sat, 15 Mar 2025 20:30:10 GMT
```

### Mysql

현재 프로젝트에서는 Java와 Mysql을 사용하고 있는데, 금융권이다보니 정말 이런 곳에서도 폐쇄적인 건지..아무튼 타임스탬프를 사용하기 위해서 데이터베이스 관리 부서와의 협의과정을 거쳐서 겨우 사용하게 되었다.

그렇게 해서 사용하게 된 현재 프로젝트의 타임스탬프를 저장하는 컬럼의 타입은 `CHAR(13)`으로 설정이 되어있다.

현재 사용하고 있는 방식은 spring boot 에서 querydsl 로 데이터베이스에 저장을 할 때 `System.currentTimeMillis()`을 통해 직접 set을 하는 방식인데, 원래 mysql에서는 `TIMESTAMP`라는 속성도 있다는 것을 알게 되었다.

```mysql
mysql&gt; CREATE TABLE TEST_DB (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name varchar(30),
    craete_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


mysql&gt; INSERT INTO TEST_DB (name) VALUES (&#x27;Sample name&#x27;);
+----+-------------+---------------------+
| id | name        | craete_at           |
+----+-------------+---------------------+
|  1 | Sample name | 2025-03-16 21:54:50 |
+----+-------------+---------------------+
```

아래에서는 타임스탬프를 ms까지 포함하는 컬럼을 의미한다.

```mysql
mysql&gt; CREATE TABLE TEST_DB_MS (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name varchar(30),
    craete_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


mysql&gt; INSERT INTO TEST_DB_MS (name) VALUES (&#x27;Sample name&#x27;);
+----+-------------+-------------------------+
| id | event_name  | event_time              |
+----+-------------+-------------------------+
|  1 | Sample name | 2025-03-16 22:07:55.981 |
+----+-------------+-------------------------+
```
하지만 위의 방식은 여전히 타임존을 포함하고 있지 않기 때문에 지금 프로젝트에서는 적합하지 않았고, 그래서 mysql 에서도 만약 Unix Timestamp를 활용하고 싶다면

```mysql
mysql&gt; CREATE TABLE TEST_DB_UNIX_TIME (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    create_at BIGINT
);


mysql&gt; INSERT INTO TEST_DB_UNIX_TIME (create_at) VALUES (UNIX_TIMESTAMP());
+----+-------------+
| id |  create_at  |
+----+-------------+
|  1 | 1742130982  |
+----+-------------+
```
만약, 해당하는 값을 사람이 이해할 수 있게 조회를 하게 된다면 `FROM_UNIXTIME`을 사용하면 된다.
```mysql
mysql&gt; SELECT id, FROM_UNIXTIME(create_at) AS read_time FROM TEST_DB_UNIX_TIME;

+----+---------------------+
| id |     read_time       |
+----+---------------------+
|  1 | 2025-03-16 22:16:22 |
+----+---------------------+
```

위에서 계속 얘기했던 타임존을 포함한 시간을 조회하기 위해선, 일단 본인의 서버 타임존을 확인해본다. 나는 기본 SYSTEM 타임존을 따르는 것을 확인할 수 있고,
```mysql
mysql&gt; SELECT @@global.time_zone, @@session.time_zone, @@system_time_zone;
+--------------------+---------------------+
| @@global.time_zone | @@session.time_zone |
+--------------------+---------------------+
| SYSTEM             | SYSTEM              |
+--------------------+---------------------+
```
디폴트 타임존 설정이 되어 있지 않을 경우, 현재 내가 원하는 타임존으로 조회할 수 있는 방법은 `CONVERT_TZ`를 통해 조회할 수 있다.
```mysql
mysql&gt; SELECT id, CONVERT_TZ(FROM_UNIXTIME(create_at), &#x27;+00:00&#x27;, &#x27;-09:00&#x27;) AS seoul_time FROM TEST_DB_UNIX_TIME;
+----+---------------------+
| id | seoul_time          |
+----+---------------------+
|  1 | 2025-03-16 13:16:22 |
+----+---------------------+
```

추가로 [7.1.15 MySQL Server Time Zone Support](https://dev.mysql.com/doc/refman/8.4/en/time-zone-support.html)에서 타임존에 대한 Mysql에 대한 설명을 볼 수 있었다.
간단하게 요약해보면,
MySQL 서버의 초기 글로벌 서버 시간대는 `default-time-zone` 설정을 통해 할 수 있고,
```mysql
default-time-zone=&#x27;timezone&#x27;
```

만약, `SYSTEM_VARIABLES_ADMIN` 권한이 존재하면 다음 명령어로 설정하고 조회할 수 있다.
```mysql
SET GLOBAL time_zone = timezone;
```

여기서의 세션 시간대 설정은 `NOW()` 또는 `CURTIME()`과 같은 함수에서 표시하는 값과 TIMESTAMP 열에 저장되고 검색되는 값이 포함된다.
하지만, `UTC_TIMESTAMP()`, `DATE`, `TIME`, `DATETIME` 로 저장된 값의 경우는 시간대에 영향을 받지 않기 때문에 시간대를 설정한다고 해서 자동으로 변환되는 것이 아니다.

`UTC_TIMESTAMP()`는 항상 UTC 기준으로 조회가 되는 것을 확인할 수 있다.
```mysql
mysql&gt; SET time_zone = &#x27;Asia/Seoul&#x27;;

mysql&gt; SELECT UTC_TIMESTAMP();
+---------------------+
| UTC_TIMESTAMP()     |
+---------------------+
| 2025-03-16 13:55:08 |  -- UTC 기준으로 출력됨
+---------------------+
```
하지만, `TIMESTAMP`는 값은 UTC로 저장되고, 조회할 때 세션 시간대에 맞게 변환된다.
```mysql
mysql&gt; SET time_zone = &#x27;Asia/Seoul&#x27;;
mysql&gt; INSERT INTO TEST_DB_UNIX_TIME (create_at) VALUES (UNIX_TIMESTAMP());
mysql&gt; SELECT create_at FROM TEST_DB_UNIX_TIME;
+---------------------+
| create_at           |
+---------------------+
| 2025-03-16 22:16:22 |  -- 서울 시간(UTC+9)이 출력됨
+---------------------+
```


</div></li></a><a class="w-full" href="/posts/01_Handling-Large-Scale-Processing-In-Spring-Boot"><li class="flex w-full flex-wrap gap-6 rounded-lg bg-gray-200 px-5 py-4 shadow-md transition duration-300 hover:shadow-lg"><div class="flex flex-1 flex-wrap gap-2"><h3 class="w-full text-lg font-semibold text-gray-800">Handling Large Scale Processing in Spring Boot</h3><p class="w-full text-sm text-gray-600">Spring Boot로 개발된 서비스를 개발 및 운영하면서 대용량 처리를 어떻게 해결 했는지 간단한 예제를 통해 정리</p><div class="flex w-full gap-2"><div class="rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900">spring boot</div><div class="rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900">대용량</div></div><p class="w-full text-sm text-gray-800">2025-03-09 16:50:00</p></div><div class="m-auto"></div><div>
프프로젝트를 진행하면서 여러 상황들을 마주치게 되었는데,
예를 들면, 폐쇄망에서의 라이브러리 관련 설정이나, M1에서의 Minikube 설정 방법처럼 초기 설정 관련 문제부터 시작해서
프로덕트를 운영하면서 데이터베이스에 대량의 데이터가 축적되게 되어 발생하는 문제나 대용량 INSERT로 인해 발생한 화면에서의 로딩 및 타임아웃 문제 등과 같은 상황들

이런 문제들에 대한 해결 과정을 정리하거나 공유하지 않다 보니, 내가 과연 맞는 방법으로 가고 있는 건지 모르겠다는 생각이 들었다.

그래서 이번 시리즈를 시작하면서, 현재 내가 하고 있는 고민이나 해결 방법, 나의 한계를 공유해보자는 마음가짐을 가지게 되었다.
첫 번째 주제는 최근에 회사 프로젝트를 하면서 마주친 문제 중 대용량 데이터의 INSERT 문제 및 대용량 처리에 대해 고민해보려고 한다.

같이 프로젝트를 진행하고 있는 팀 동기와 함께 이 주제를 정하게 되었고, 주제를 정하고 나서 개인 공부 시간을 1주일 동안 가졌는데..
(~~사실 이번주는 첫 블로그 글이어서 3일 정도 밖에 생각하지 못했는데,,,반성하자~~)

첫 주제를 정하다 보니 너무 큰 주제를 정한 건 아닌가 싶기도 했다. `대용량` 이라는 주제가 너무 광범위 했고, 어디부터 어디까지 시작을 해야할 지 정하지 못한 채로 일주일이 금방 지나가게 되었는데

```
대용량 처리 라고했는데,
과연 그 대용량의 기준은?
만약 100만건 이라는 데이터를 대용량 기준으로 정했다면 만약 100만건 각각의 데이터 크기는 고려하지 않는 건가?
대용량 처리 라고 했는데, 어느 단에서 대용량 처리를 하는 것이 맞는건지?
단순히 성능, 사양의 문제로 인해 어쩔 수 없는 상황인 건가?
무작정 성능을 높인다고 해결되는 문제일까?
성능으로 해결해야 하는 기준은 어디까지일까?

등등

```

데이터의 전처리나 배치 전송 등 Controller Level 이전에서 할 수 있는 방법들도 고민할 수 있겠지만,
일단 백엔드 개발자 관점에서 할 수 있는 방법들로만 찾아보았고, 이번 시리즈에서는 그 고민과 해결 방법들을 찾아보려고 한다.


&lt;hr /&gt;

### Controller Level
1. RequestBody 크기 제한 설정
  - application.yml(properties) 설정

### Service Level
1. Batch Processing
2. Asynchronous Processing
3. Parallel Processing
4. Spring Batch
5. Caching

### Repository Level
1. Batch Insert
2. Efficient Query
  - 최적화 쿼리 필요
3. Transaction

### MySQL Level
1. Index 설정
2. Partitioning
  - 조회할 때의 성능 고려
3. 다중 쓰기
  - LOAD DATA ...

</div></li></a><a class="w-full" href="/posts/02_Handling-Large-Scale-Processing-Service-Level"><li class="flex w-full flex-wrap gap-6 rounded-lg bg-gray-200 px-5 py-4 shadow-md transition duration-300 hover:shadow-lg"><div class="flex flex-1 flex-wrap gap-2"><h3 class="w-full text-lg font-semibold text-gray-800">Handling Large Scale Processing in Spring Boot - (1) Service Level</h3><p class="w-full text-sm text-gray-600">Spring Boot로 개발된 서비스를 개발 및 운영하면서 대용량 처리를 어떻게 해결 했는지 간단한 예제를 통해 정리</p><div class="flex w-full gap-2"><div class="rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900">spring boot</div><div class="rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900">대용량</div></div><p class="w-full text-sm text-gray-800">2025-03-09 16:50:00</p></div><div class="m-auto"></div><div>
이전 글에서는 할 수 있는 방법들을 찾아보는 시간이었고, 이번에는 Service 레벨에서 할 수 있는 방법들을 직접 구현해보고 테스트해보았다.

# Service Level

### Batch Processing


### Asynchronous Processing


### Parallel Processing


### Spring Batch


### Caching

</div></li></a><a class="w-full" href="/posts/00_How-to-use-markdown"><li class="flex w-full flex-wrap gap-6 rounded-lg bg-gray-200 px-5 py-4 shadow-md transition duration-300 hover:shadow-lg"><div class="flex flex-1 flex-wrap gap-2"><h3 class="w-full text-lg font-semibold text-gray-800">Markdown 문법</h3><p class="w-full text-sm text-gray-600">Markdown 으로 작성 가능한 모든 문법</p><div class="flex w-full gap-2"><div class="rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900">markdown</div></div><p class="w-full text-sm text-gray-800">2025-03-04 11:12:00</p></div><div class="m-auto"></div><div>
# 제목
# H1

## H2

### H3

#### H4

##### H5

###### H6
---

# 강조
*이테리체*
**볼드체**

---

# 목록
1. 순서가 있는 항목

- 순서가 없는 항목
---

# 링크
[GOOGLE](https://google.com)

---

# 이미지
![대체 텍스트](https://picsum.photos/100/100)

---

# 코드 강조
`인라인`

```js
console.log(&quot;code block&quot;)
```
---

# 기호 사용
\`
&lt;br /&gt;
\|

---

# 표

| 헤더 | 헤더 |
|---|:---:|
| 셀 | 셀 |
| 셀 | 셀 |

---

# 인용문
&gt; 인용문

---


# 줄바꿈

```markdown
&lt;br /&gt;
```
---

# 주석

```markdown
{/* Your comment here */}
&lt;!-- 주석 --&gt;
```
---
</div></li></a></ul></main><footer class="flex h-10 w-full flex-col items-center justify-center"><span class="text-xs">Copyright © <!-- -->2025<!-- --> Sandy</span></footer></div><script src="/_next/static/chunks/webpack-f029a09104d09cbc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[8173,[\"974\",\"static/chunks/app/page-e75cc3ebefafaa5f.js\"],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n8:I[6213,[],\"ViewportBoundary\"]\na:I[6213,[],\"MetadataBoundary\"]\nc:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/268d08043a30bfbf.css\",\"style\"]\n0:{\"P\":null,\"b\":\"wKqTVR7dyH9-zJyAO2kEk\",\"p\":\"\",\"c\":[\"\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/268d08043a30bfbf.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto flex min-h-screen max-w-screen-xl flex-col px-4 sm:px-6 md:px-8 lg:px-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"container mx-auto max-w-screen-md p-4\",\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"children\":\"Hello, World\"}]}],\"$L3\",[\"$\",\"footer\",null,{\"className\":\"flex h-10 w-full flex-col items-center justify-center\",\"children\":[\"$\",\"span\",null,{\"className\":\"text-xs\",\"children\":[\"Copyright © \",2025,\" Sandy\"]}]}]]}]}]}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",\"$undefined\",null,[\"$\",\"$L5\",null,{\"children\":[\"$L6\",\"$L7\",null]}]]}],{},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"nHrxgVe3FIiJLCb2P5jno\",{\"children\":[[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$La\",null,{\"children\":\"$Lb\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$c\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"d:I[5244,[],\"\"]\ne:I[3866,[],\"\"]\n3:[\"$\",\"main\",null,{\"className\":\"container mx-auto max-w-screen-md flex-1 p-4\",\"children\":[\"$\",\"$Ld\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"$undefined\",[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]\n"])</script><script>self.__next_f.push([1,"9:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n6:null\n"])</script><script>self.__next_f.push([1,"7:null\nb:[[\"$\",\"title\",\"0\",{\"children\":\"My Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Sandy's Blog\"}]]\n"])</script><script>self.__next_f.push([1,"f:T2d8e,"])</script><script>self.__next_f.push([1,"\n# Unix Time 이전의 시간 저장 방식\n\n### 1. Date String\n\n```markdown\n2025-03-15 20:30:10\n```\n\n1. 장점\n  - 사람이 읽고 이해할 수 있는 형태로 가독성이 좋음\n2. 단점\n  - 문자열로 저장되어 있다보니 날짜를 비교에 변환 과정이 추가로 필요\n  - 각 시스템에서 타임존에 따른 문제점 발생\n\n### 2. 이진수 or BCD(Binary Coded Decimal) 방식\n\n|    항목    |     이진수     |         BCD         |\n|:--------:|:-----------:|:-------------------:|\n| 연 (2025) | 11111100101 | 0010 0000 0010 0101 |\n|  월 (03)  |  00000011   |      0000 0011      |\n|  일 (15)  |  00001111   |      0001 0101      |\n|  시 (20)  |  00010100   |      0010 0000      |\n|  분 (30)  |  00111110   |      0011 0000      |\n|  초 (10)  |  00001010   |      0001 0000      |\n\n1. 장점\n  - 이진수로 저장을 하다보니 컴퓨터가 이해하기 쉬움\n  - 이진법 숫자 연산을 통해 시간 비교나 계산 빠름\n2. 단점\n  - 사람이 이해하기 어려움\n  - 각 시스템에서 타임존에 따른 문제점 발생\n\n### 3. Timestamp\n\n```markdown\n2025-03-15T20:30:10Z (Z = Zulu Time = UTC)\n2025-03-15T20:30:10+09:00 (UTC+9 시간대)\n```\n\n1. 장점\n  - 사람이 이해하기 쉬움\n  - 시간대를 포함하고 있음\n2. 단점\n  - 타임스탬프 형태이지만 문자열로 저장하기 때문에 저장 공간이 많이 필요함\n  - 문자열로 저장하기 때문에 비교나 계산에서 추가 변환 과정이 필요함\n\n이 외에도 날짜와 시간을 다른 필드로 별도 관리하는 방법이나 다양한 방법들이 있지만, 이러한 방식들은 시간 비교 계산이나 시간대의 문제에서 많은 한계를 마주치게 되었고,\n\n그래서 **Unix Time**은 시간 계산 편리를 위해 숫자로 관리를 하고 있고, UTC라는 기준 시간대를 사용하여 동일한 기준으로 시간을 관리하게 되었다.\n\n\u003e **Unix Time ? Timestamp ?**Timestamp를 직역하면 **시간 도장**이라는 의미인데, 특정 시점의 기록을 도장처럼 기록하는 의미를 가지고 있다. **Unix Time**은 이러한 Timestamp의 표현 방식 중 하나로, 정수 형태로\n\u003e 초를 기록하는 방식이다.ex.`2025-03-15T20:30:10Z` : 사람이 읽을 수 있는 형태로 표현한 Timestamp\n\n\u003chr /\u003e\n\n# Unix Time\n\n```markdown\nUNIX 시간(UNIX time)은 시각을 나타내는 방식이다. POSIX 시간이나 Epoch 시간이라고 부르기도 한다.\n1970년 1월 1일 00:00:00 협정 세계시(UTC) 부터의 경과 시간을 초로 환산하여 정수로 나타낸 것이다.\n```\n\n[Wikipedia - Unix Time](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%8B%9C%EA%B0%84) 에 적혀있는 Unix Time에\n대한 설명인데,\n\n**1970년 01월 01알 00:00:00 시를 0으로 기준을 설정하고, 그 이후에 흘러간 시간을 초로 환산하여 32bit 의 정수로 나타낸 것이 Unix Time 이다.**\n\n\u003e **Unix Time이 1970-01-01 00:00:00 이 기준이 된 이유**Unix가 처음 개발될 1970년대 당시에 개발자들이 정한 기준점이라고 한다.\n\u003e 그래서 그 이전의 시간은 음수값으롲 정의된다.\n\n### 특징\n\n##### 1. Epoch Time (기준 시간)이 있다.\n\n- `Epoch` : 1970-01-01 00:00:00 UTC\n\n##### 2. 초 단위로 시간을 관리한다.\n\n- `1742043549` : 2025년 3월 15일 토요일 21시 59분 11초\n\n##### 3. 기준이 되는 타임존은  UTC이다.\n\n### 문제점\n\n이러한 유용한 Unix Time에도 문제점이 존재하는데,\n\n##### 1. [윤초](https://ko.wikipedia.org/wiki/%EC%9C%A4%EC%B4%88)를 고려하지 않음\n\n- 지구 자전 속도에 따라 추가되는 초인 윤초를 고려하지 않고 있다.\n\n##### 2. 2038년 문제 (Y2K38)\n\n이건 이번에 Timestamp에 대한 공부를 하면서 깨닫게 되었는데, 생각해보면 무한한 시간을 유한한 숫자로 표현하게 만들어 두었다는 거에 있어서 한계가 있을 텐데 그게 바로 이 2038년 문제라고 한다.\n\n- Unix Time은 1970-01-01 00:00:00 UTC를 기준으로 경과한 초를 32비트 정수로 저장하고 있기 때문에, **32bit (2,147,483,647)** 까지 표현 가능하다.\n- `1970-01-01 00:00:00 으로부터 2147483647초 후`는 2038년 1월 19일 03:14:07 UTC 이기 때문에 **2038년 문제**라고 불리운다.\n- 그 이후의 시간은 오버플로우(overflow)가 발생하여 음수로 변환되어 날짜계산에 문제가 발생하게 된다.\n- **해결방법** : 32bit 방식을 64bit 방식으로 처리하게 되면 해결됨\n\n\u003chr /\u003e\n\n# Timestamp 사용법\n### Linux/Unix\n```shell title=\"Linux/Unix Timestamp\"\n\u003e date +%s\n1742045410\n```\n\n```shell title=\"Linux/Unix Timestamp(날짜/시간)\"\n\u003e date\nSat Mar 15 20:30:10 UTC 2025\n```\n\n### Java\n```java title=\"Java Timestamp\"\nlong currentUnixTimeMs = System.currentTimeMillis();\nSystem.out.println(currentUnixTimeMs); // 1742045410000\n```\n\n```java title=\"Java Timestamp (날짜/시간)\"\nimport java.util.Date;\n\n\npublic static void main(String[] args) {\n    long currentUnixTimeMs = System.currentTimeMillis();\n    Date date = new Date(currentUnixTimeMs);\n    System.out.println(date.toString()); // Mon Mar 15 20:30:10 GMT 2025\n}\n```\n\n```java title=\"Java Timestamp (날짜/시간) - Java8 이상\"\nimport java.time.Instant;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\n\n\npublic static void main(String[] args) {\n    long currentUnixTimeMs = System.currentTimeMillis();\n    Instant instant = Instant.ofEpochMilli(currentUnixTimeMs);\n    String formattedDate = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")\n                            .withZone(ZoneId.systemDefault())\n                            .format(instant);\n    System.out.println(formattedDate); // 2025-03-15 20:30:10\n}\n```\n\n### Python\n```python title=\"Python Timestamp\"\ncurrent_unix_time_ms = int(time.time() * 1000)\nprint(current_unix_time_ms) # 1742043549000\n```\n\n```python title=\"Python Timestamp (날짜/시간)\"\nfrom datetime import datetime\n\nunix_time_ms = int(time.time())\nconverted_time = datetime.utcfromtimestamp(unix_time_ms)\nprint(converted_time) # 2025-03-15 20:30:10\n```\n\n### Javascript\n```javascript title=\"Javascript Timestamp\"\nlet currentUnixTimeMs = Date.now()\nconsole.log(currentUnixTimeMs) // 1742043549000\n```\n\n```javascript title=\"Javascript Timestamp (날짜/시간)\"\nlet date = new Date.now()\nconsole.log(date.toUTCString()) // Sat, 15 Mar 2025 20:30:10 GMT\n```\n\n### Mysql\n\n현재 프로젝트에서는 Java와 Mysql을 사용하고 있는데, 금융권이다보니 정말 이런 곳에서도 폐쇄적인 건지..아무튼 타임스탬프를 사용하기 위해서 데이터베이스 관리 부서와의 협의과정을 거쳐서 겨우 사용하게 되었다.\n\n그렇게 해서 사용하게 된 현재 프로젝트의 타임스탬프를 저장하는 컬럼의 타입은 `CHAR(13)`으로 설정이 되어있다.\n\n현재 사용하고 있는 방식은 spring boot 에서 querydsl 로 데이터베이스에 저장을 할 때 `System.currentTimeMillis()`을 통해 직접 set을 하는 방식인데, 원래 mysql에서는 `TIMESTAMP`라는 속성도 있다는 것을 알게 되었다.\n\n```mysql\nmysql\u003e CREATE TABLE TEST_DB (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name varchar(30),\n    craete_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n\nmysql\u003e INSERT INTO TEST_DB (name) VALUES ('Sample name');\n+----+-------------+---------------------+\n| id | name        | craete_at           |\n+----+-------------+---------------------+\n|  1 | Sample name | 2025-03-16 21:54:50 |\n+----+-------------+---------------------+\n```\n\n아래에서는 타임스탬프를 ms까지 포함하는 컬럼을 의미한다.\n\n```mysql\nmysql\u003e CREATE TABLE TEST_DB_MS (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name varchar(30),\n    craete_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n\nmysql\u003e INSERT INTO TEST_DB_MS (name) VALUES ('Sample name');\n+----+-------------+-------------------------+\n| id | event_name  | event_time              |\n+----+-------------+-------------------------+\n|  1 | Sample name | 2025-03-16 22:07:55.981 |\n+----+-------------+-------------------------+\n```\n하지만 위의 방식은 여전히 타임존을 포함하고 있지 않기 때문에 지금 프로젝트에서는 적합하지 않았고, 그래서 mysql 에서도 만약 Unix Timestamp를 활용하고 싶다면\n\n```mysql\nmysql\u003e CREATE TABLE TEST_DB_UNIX_TIME (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    create_at BIGINT\n);\n\n\nmysql\u003e INSERT INTO TEST_DB_UNIX_TIME (create_at) VALUES (UNIX_TIMESTAMP());\n+----+-------------+\n| id |  create_at  |\n+----+-------------+\n|  1 | 1742130982  |\n+----+-------------+\n```\n만약, 해당하는 값을 사람이 이해할 수 있게 조회를 하게 된다면 `FROM_UNIXTIME`을 사용하면 된다.\n```mysql\nmysql\u003e SELECT id, FROM_UNIXTIME(create_at) AS read_time FROM TEST_DB_UNIX_TIME;\n\n+----+---------------------+\n| id |     read_time       |\n+----+---------------------+\n|  1 | 2025-03-16 22:16:22 |\n+----+---------------------+\n```\n\n위에서 계속 얘기했던 타임존을 포함한 시간을 조회하기 위해선, 일단 본인의 서버 타임존을 확인해본다. 나는 기본 SYSTEM 타임존을 따르는 것을 확인할 수 있고,\n```mysql\nmysql\u003e SELECT @@global.time_zone, @@session.time_zone, @@system_time_zone;\n+--------------------+---------------------+\n| @@global.time_zone | @@session.time_zone |\n+--------------------+---------------------+\n| SYSTEM             | SYSTEM              |\n+--------------------+---------------------+\n```\n디폴트 타임존 설정이 되어 있지 않을 경우, 현재 내가 원하는 타임존으로 조회할 수 있는 방법은 `CONVERT_TZ`를 통해 조회할 수 있다.\n```mysql\nmysql\u003e SELECT id, CONVERT_TZ(FROM_UNIXTIME(create_at), '+00:00', '-09:00') AS seoul_time FROM TEST_DB_UNIX_TIME;\n+----+---------------------+\n| id | seoul_time          |\n+----+---------------------+\n|  1 | 2025-03-16 13:16:22 |\n+----+---------------------+\n```\n\n추가로 [7.1.15 MySQL Server Time Zone Support](https://dev.mysql.com/doc/refman/8.4/en/time-zone-support.html)에서 타임존에 대한 Mysql에 대한 설명을 볼 수 있었다.\n간단하게 요약해보면,\nMySQL 서버의 초기 글로벌 서버 시간대는 `default-time-zone` 설정을 통해 할 수 있고,\n```mysql\ndefault-time-zone='timezone'\n```\n\n만약, `SYSTEM_VARIABLES_ADMIN` 권한이 존재하면 다음 명령어로 설정하고 조회할 수 있다.\n```mysql\nSET GLOBAL time_zone = timezone;\n```\n\n여기서의 세션 시간대 설정은 `NOW()` 또는 `CURTIME()`과 같은 함수에서 표시하는 값과 TIMESTAMP 열에 저장되고 검색되는 값이 포함된다.\n하지만, `UTC_TIMESTAMP()`, `DATE`, `TIME`, `DATETIME` 로 저장된 값의 경우는 시간대에 영향을 받지 않기 때문에 시간대를 설정한다고 해서 자동으로 변환되는 것이 아니다.\n\n`UTC_TIMESTAMP()`는 항상 UTC 기준으로 조회가 되는 것을 확인할 수 있다.\n```mysql\nmysql\u003e SET time_zone = 'Asia/Seoul';\n\nmysql\u003e SELECT UTC_TIMESTAMP();\n+---------------------+\n| UTC_TIMESTAMP()     |\n+---------------------+\n| 2025-03-16 13:55:08 |  -- UTC 기준으로 출력됨\n+---------------------+\n```\n하지만, `TIMESTAMP`는 값은 UTC로 저장되고, 조회할 때 세션 시간대에 맞게 변환된다.\n```mysql\nmysql\u003e SET time_zone = 'Asia/Seoul';\nmysql\u003e INSERT INTO TEST_DB_UNIX_TIME (create_at) VALUES (UNIX_TIMESTAMP());\nmysql\u003e SELECT create_at FROM TEST_DB_UNIX_TIME;\n+---------------------+\n| create_at           |\n+---------------------+\n| 2025-03-16 22:16:22 |  -- 서울 시간(UTC+9)이 출력됨\n+---------------------+\n```\n\n\n"])</script><script>self.__next_f.push([1,"10:Tb2a,"])</script><script>self.__next_f.push([1,"\n프프로젝트를 진행하면서 여러 상황들을 마주치게 되었는데,\n예를 들면, 폐쇄망에서의 라이브러리 관련 설정이나, M1에서의 Minikube 설정 방법처럼 초기 설정 관련 문제부터 시작해서\n프로덕트를 운영하면서 데이터베이스에 대량의 데이터가 축적되게 되어 발생하는 문제나 대용량 INSERT로 인해 발생한 화면에서의 로딩 및 타임아웃 문제 등과 같은 상황들\n\n이런 문제들에 대한 해결 과정을 정리하거나 공유하지 않다 보니, 내가 과연 맞는 방법으로 가고 있는 건지 모르겠다는 생각이 들었다.\n\n그래서 이번 시리즈를 시작하면서, 현재 내가 하고 있는 고민이나 해결 방법, 나의 한계를 공유해보자는 마음가짐을 가지게 되었다.\n첫 번째 주제는 최근에 회사 프로젝트를 하면서 마주친 문제 중 대용량 데이터의 INSERT 문제 및 대용량 처리에 대해 고민해보려고 한다.\n\n같이 프로젝트를 진행하고 있는 팀 동기와 함께 이 주제를 정하게 되었고, 주제를 정하고 나서 개인 공부 시간을 1주일 동안 가졌는데..\n(~~사실 이번주는 첫 블로그 글이어서 3일 정도 밖에 생각하지 못했는데,,,반성하자~~)\n\n첫 주제를 정하다 보니 너무 큰 주제를 정한 건 아닌가 싶기도 했다. `대용량` 이라는 주제가 너무 광범위 했고, 어디부터 어디까지 시작을 해야할 지 정하지 못한 채로 일주일이 금방 지나가게 되었는데\n\n```\n대용량 처리 라고했는데,\n과연 그 대용량의 기준은?\n만약 100만건 이라는 데이터를 대용량 기준으로 정했다면 만약 100만건 각각의 데이터 크기는 고려하지 않는 건가?\n대용량 처리 라고 했는데, 어느 단에서 대용량 처리를 하는 것이 맞는건지?\n단순히 성능, 사양의 문제로 인해 어쩔 수 없는 상황인 건가?\n무작정 성능을 높인다고 해결되는 문제일까?\n성능으로 해결해야 하는 기준은 어디까지일까?\n\n등등\n\n```\n\n데이터의 전처리나 배치 전송 등 Controller Level 이전에서 할 수 있는 방법들도 고민할 수 있겠지만,\n일단 백엔드 개발자 관점에서 할 수 있는 방법들로만 찾아보았고, 이번 시리즈에서는 그 고민과 해결 방법들을 찾아보려고 한다.\n\n\n\u003chr /\u003e\n\n### Controller Level\n1. RequestBody 크기 제한 설정\n  - application.yml(properties) 설정\n\n### Service Level\n1. Batch Processing\n2. Asynchronous Processing\n3. Parallel Processing\n4. Spring Batch\n5. Caching\n\n### Repository Level\n1. Batch Insert\n2. Efficient Query\n  - 최적화 쿼리 필요\n3. Transaction\n\n### MySQL Level\n1. Index 설정\n2. Partitioning\n  - 조회할 때의 성능 고려\n3. 다중 쓰기\n  - LOAD DATA ...\n\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"ul\",null,{\"className\":\"flex flex-wrap justify-start gap-6\",\"children\":[[\"$\",\"$L2\",\"03_Timestamp\",{\"className\":\"w-full\",\"href\":\"/posts/03_Timestamp\",\"children\":[\"$\",\"li\",null,{\"className\":\"flex w-full flex-wrap gap-6 rounded-lg bg-gray-200 px-5 py-4 shadow-md transition duration-300 hover:shadow-lg\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-1 flex-wrap gap-2\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"w-full text-lg font-semibold text-gray-800\",\"children\":\"Timestamp 란\"}],[\"$\",\"p\",null,{\"className\":\"w-full text-sm text-gray-600\",\"children\":\"현재 시스템에서 사용하고 있는 Timestamp에 대한 개념과 사용법을 정리\"}],[\"$\",\"div\",null,{\"className\":\"flex w-full gap-2\",\"children\":[[\"$\",\"div\",\"timestamp\",{\"className\":\"rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900\",\"children\":\"timestamp\"}]]}],[\"$\",\"p\",null,{\"className\":\"w-full text-sm text-gray-800\",\"children\":\"2025-03-16 16:50:00\"}]]}],[\"$\",\"div\",null,{\"className\":\"m-auto\"}],[\"$\",\"div\",null,{\"children\":\"$f\"}]]}]}],[\"$\",\"$L2\",\"01_Handling-Large-Scale-Processing-In-Spring-Boot\",{\"className\":\"w-full\",\"href\":\"/posts/01_Handling-Large-Scale-Processing-In-Spring-Boot\",\"children\":[\"$\",\"li\",null,{\"className\":\"flex w-full flex-wrap gap-6 rounded-lg bg-gray-200 px-5 py-4 shadow-md transition duration-300 hover:shadow-lg\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-1 flex-wrap gap-2\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"w-full text-lg font-semibold text-gray-800\",\"children\":\"Handling Large Scale Processing in Spring Boot\"}],[\"$\",\"p\",null,{\"className\":\"w-full text-sm text-gray-600\",\"children\":\"Spring Boot로 개발된 서비스를 개발 및 운영하면서 대용량 처리를 어떻게 해결 했는지 간단한 예제를 통해 정리\"}],[\"$\",\"div\",null,{\"className\":\"flex w-full gap-2\",\"children\":[[\"$\",\"div\",\"spring boot\",{\"className\":\"rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900\",\"children\":\"spring boot\"}],[\"$\",\"div\",\"대용량\",{\"className\":\"rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900\",\"children\":\"대용량\"}]]}],[\"$\",\"p\",null,{\"className\":\"w-full text-sm text-gray-800\",\"children\":\"2025-03-09 16:50:00\"}]]}],[\"$\",\"div\",null,{\"className\":\"m-auto\"}],[\"$\",\"div\",null,{\"children\":\"$10\"}]]}]}],[\"$\",\"$L2\",\"02_Handling-Large-Scale-Processing-Service-Level\",{\"className\":\"w-full\",\"href\":\"/posts/02_Handling-Large-Scale-Processing-Service-Level\",\"children\":[\"$\",\"li\",null,{\"className\":\"flex w-full flex-wrap gap-6 rounded-lg bg-gray-200 px-5 py-4 shadow-md transition duration-300 hover:shadow-lg\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-1 flex-wrap gap-2\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"w-full text-lg font-semibold text-gray-800\",\"children\":\"Handling Large Scale Processing in Spring Boot - (1) Service Level\"}],[\"$\",\"p\",null,{\"className\":\"w-full text-sm text-gray-600\",\"children\":\"Spring Boot로 개발된 서비스를 개발 및 운영하면서 대용량 처리를 어떻게 해결 했는지 간단한 예제를 통해 정리\"}],[\"$\",\"div\",null,{\"className\":\"flex w-full gap-2\",\"children\":[[\"$\",\"div\",\"spring boot\",{\"className\":\"rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900\",\"children\":\"spring boot\"}],[\"$\",\"div\",\"대용량\",{\"className\":\"rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900\",\"children\":\"대용량\"}]]}],[\"$\",\"p\",null,{\"className\":\"w-full text-sm text-gray-800\",\"children\":\"2025-03-09 16:50:00\"}]]}],[\"$\",\"div\",null,{\"className\":\"m-auto\"}],[\"$\",\"div\",null,{\"children\":\"\\n이전 글에서는 할 수 있는 방법들을 찾아보는 시간이었고, 이번에는 Service 레벨에서 할 수 있는 방법들을 직접 구현해보고 테스트해보았다.\\n\\n# Service Level\\n\\n### Batch Processing\\n\\n\\n### Asynchronous Processing\\n\\n\\n### Parallel Processing\\n\\n\\n### Spring Batch\\n\\n\\n### Caching\\n\\n\"}]]}]}],[\"$\",\"$L2\",\"00_How-to-use-markdown\",{\"className\":\"w-full\",\"href\":\"/posts/00_How-to-use-markdown\",\"children\":[\"$\",\"li\",null,{\"className\":\"flex w-full flex-wrap gap-6 rounded-lg bg-gray-200 px-5 py-4 shadow-md transition duration-300 hover:shadow-lg\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-1 flex-wrap gap-2\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"w-full text-lg font-semibold text-gray-800\",\"children\":\"Markdown 문법\"}],[\"$\",\"p\",null,{\"className\":\"w-full text-sm text-gray-600\",\"children\":\"Markdown 으로 작성 가능한 모든 문법\"}],[\"$\",\"div\",null,{\"className\":\"flex w-full gap-2\",\"children\":[[\"$\",\"div\",\"markdown\",{\"className\":\"rounded-full bg-green-100 px-2 py-1 text-xs text-gray-900\",\"children\":\"markdown\"}]]}],[\"$\",\"p\",null,{\"className\":\"w-full text-sm text-gray-800\",\"children\":\"2025-03-04 11:12:00\"}]]}],[\"$\",\"div\",null,{\"className\":\"m-auto\"}],[\"$\",\"div\",null,{\"children\":\"\\n# 제목\\n# H1\\n\\n## H2\\n\\n### H3\\n\\n#### H4\\n\\n##### H5\\n\\n###### H6\\n---\\n\\n# 강조\\n*이테리체*\\n**볼드체**\\n\\n---\\n\\n# 목록\\n1. 순서가 있는 항목\\n\\n- 순서가 없는 항목\\n---\\n\\n# 링크\\n[GOOGLE](https://google.com)\\n\\n---\\n\\n# 이미지\\n![대체 텍스트](https://picsum.photos/100/100)\\n\\n---\\n\\n# 코드 강조\\n`인라인`\\n\\n```js\\nconsole.log(\\\"code block\\\")\\n```\\n---\\n\\n# 기호 사용\\n\\\\`\\n\u003cbr /\u003e\\n\\\\|\\n\\n---\\n\\n# 표\\n\\n| 헤더 | 헤더 |\\n|---|:---:|\\n| 셀 | 셀 |\\n| 셀 | 셀 |\\n\\n---\\n\\n# 인용문\\n\u003e 인용문\\n\\n---\\n\\n\\n# 줄바꿈\\n\\n```markdown\\n\u003cbr /\u003e\\n```\\n---\\n\\n# 주석\\n\\n```markdown\\n{/* Your comment here */}\\n\u003c!-- 주석 --\u003e\\n```\\n---\\n\"}]]}]}]]}]\n"])</script></body></html>